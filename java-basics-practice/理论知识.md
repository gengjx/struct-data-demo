# Java基础阶段理论知识

本文档涵盖Java基础阶段（第一部分）的所有理论知识，是学习Java编程的理论基础。

---

## 目录

1. [Java语法基础](#1-java语法基础)
2. [数组和字符串](#2-数组和字符串)
3. [面向对象编程](#3-面向对象编程)
4. [接口、抽象类、内部类](#4-接口抽象类内部类)
5. [枚举和注解](#5-枚举和注解)
6. [集合框架](#6-集合框架)
7. [I/O流](#7-io流)
8. [多线程](#8-多线程)
9. [异常处理和反射](#9-异常处理和反射)
10. [Lambda表达式和Stream API](#10-lambda表达式和stream-api)

---

## 1. Java语法基础

### 1.1 变量和数据类型

#### 1.1.1 基本数据类型

Java有8种基本数据类型：

| 类型 | 大小 | 取值范围 | 默认值 |
|------|------|----------|--------|
| byte | 1字节 | -128 ~ 127 | 0 |
| short | 2字节 | -32,768 ~ 32,767 | 0 |
| int | 4字节 | -2^31 ~ 2^31-1 | 0 |
| long | 8字节 | -2^63 ~ 2^63-1 | 0L |
| float | 4字节 | IEEE 754 | 0.0f |
| double | 8字节 | IEEE 754 | 0.0d |
| char | 2字节 | 0 ~ 65,535 | '\u0000' |
| boolean | 1位 | true/false | false |

**注意事项：**
- `long`类型赋值时需要在数字后加`L`或`l`
- `float`类型赋值时需要在数字后加`F`或`f`
- `char`类型使用单引号，`String`使用双引号
- `boolean`只有`true`和`false`两个值，不能用0和1表示

#### 1.1.2 引用数据类型

引用类型包括：
- 类（Class）
- 接口（Interface）
- 数组（Array）
- 字符串（String）

引用类型的默认值是`null`。

#### 1.1.3 变量声明和初始化

```java
// 声明并初始化
int age = 25;
String name = "张三";

// 先声明后初始化
int count;
count = 10;

// 同时声明多个变量
int a = 1, b = 2, c = 3;
```

#### 1.1.4 常量

使用`final`关键字声明常量：

```java
final int MAX_SIZE = 100;
final String APP_NAME = "MyApp";
```

**常量命名规范：** 全大写字母，多个单词用下划线分隔。

### 1.2 运算符

#### 1.2.1 算术运算符

| 运算符 | 说明 | 示例 |
|--------|------|------|
| + | 加法 | a + b |
| - | 减法 | a - b |
| * | 乘法 | a * b |
| / | 除法 | a / b |
| % | 取模（余数） | a % b |
| ++ | 自增 | a++ 或 ++a |
| -- | 自减 | a-- 或 --a |

**前缀和后缀的区别：**
```java
int a = 5;
int b = ++a;  // a先自增为6，然后赋值给b，b=6
int c = a++;  // a先赋值给c，然后自增，c=6, a=7
```

#### 1.2.2 关系运算符

| 运算符 | 说明 | 示例 |
|--------|------|------|
| > | 大于 | a > b |
| < | 小于 | a < b |
| >= | 大于等于 | a >= b |
| <= | 小于等于 | a <= b |
| == | 等于 | a == b |
| != | 不等于 | a != b |

**注意：** `==`比较的是值（基本类型）或引用（引用类型），要比较对象内容应使用`equals()`方法。

#### 1.2.3 逻辑运算符

| 运算符 | 说明 | 示例 |
|--------|------|------|
| && | 逻辑与（短路） | a && b |
| \|\| | 逻辑或（短路） | a \|\| b |
| ! | 逻辑非 | !a |
| & | 逻辑与（非短路） | a & b |
| \| | 逻辑或（非短路） | a \| b |
| ^ | 逻辑异或 | a ^ b |

**短路特性：**
```java
// 如果第一个条件为false，&&不会执行第二个条件
if (a != null && a.length() > 0) { ... }

// 如果第一个条件为true，||不会执行第二个条件
if (a == null || a.isEmpty()) { ... }
```

#### 1.2.4 赋值运算符

| 运算符 | 说明 | 示例 |
|--------|------|------|
| = | 赋值 | a = 10 |
| += | 加后赋值 | a += 5 (等价于 a = a + 5) |
| -= | 减后赋值 | a -= 5 |
| *= | 乘后赋值 | a *= 5 |
| /= | 除后赋值 | a /= 5 |
| %= | 取模后赋值 | a %= 5 |

#### 1.2.5 三元运算符

```java
条件 ? 值1 : 值2
```

示例：
```java
int max = a > b ? a : b;
String result = score >= 60 ? "及格" : "不及格";
```

### 1.3 流程控制

#### 1.3.1 if-else语句

```java
// 单分支
if (condition) {
    // 代码块
}

// 双分支
if (condition) {
    // 代码块1
} else {
    // 代码块2
}

// 多分支
if (condition1) {
    // 代码块1
} else if (condition2) {
    // 代码块2
} else {
    // 代码块3
}
```

#### 1.3.2 switch语句

```java
switch (expression) {
    case value1:
        // 代码块1
        break;
    case value2:
        // 代码块2
        break;
    default:
        // 默认代码块
}
```

**注意：**
- `expression`可以是`byte`、`short`、`int`、`char`、`String`（Java 7+）、枚举
- 每个`case`后面要加`break`，否则会继续执行下一个`case`（穿透）

#### 1.3.3 for循环

```java
// 标准for循环
for (初始化; 条件; 更新) {
    // 循环体
}

// 增强for循环（for-each）
for (元素类型 变量 : 集合或数组) {
    // 循环体
}

// 示例
for (int i = 0; i < 10; i++) {
    System.out.println(i);
}

for (String str : list) {
    System.out.println(str);
}
```

#### 1.3.4 while循环

```java
while (condition) {
    // 循环体
}

// 先执行一次，再判断条件
do {
    // 循环体
} while (condition);
```

**区别：**
- `while`：先判断条件，可能一次都不执行
- `do-while`：至少执行一次

#### 1.3.5 break和continue

- `break`：跳出当前循环
- `continue`：跳过本次循环，继续下一次循环

```java
// break示例
for (int i = 0; i < 10; i++) {
    if (i == 5) {
        break;  // 当i=5时跳出循环
    }
    System.out.println(i);
}

// continue示例
for (int i = 0; i < 10; i++) {
    if (i % 2 == 0) {
        continue;  // 跳过偶数
    }
    System.out.println(i);  // 只打印奇数
}
```

---

## 2. 数组和字符串

### 2.1 数组

#### 2.1.1 数组的概念

数组是一种数据结构，用于存储同类型元素的集合。数组在内存中是连续存储的。

#### 2.1.2 数组的声明和初始化

```java
// 方式1：声明后初始化
int[] arr1 = new int[5];
arr1[0] = 1;

// 方式2：声明时初始化
int[] arr2 = {1, 2, 3, 4, 5};

// 方式3：使用new关键字
int[] arr3 = new int[]{1, 2, 3, 4, 5};

// 方式4：分步声明
int[] arr4;
arr4 = new int[]{1, 2, 3};
```

#### 2.1.3 数组的访问

```java
int[] arr = {1, 2, 3, 4, 5};
int first = arr[0];  // 访问第一个元素，索引从0开始
int length = arr.length;  // 获取数组长度
```

#### 2.1.4 数组的遍历

```java
int[] arr = {1, 2, 3, 4, 5};

// 方式1：传统for循环
for (int i = 0; i < arr.length; i++) {
    System.out.println(arr[i]);
}

// 方式2：增强for循环
for (int num : arr) {
    System.out.println(num);
}

// 方式3：使用Arrays.toString()
System.out.println(Arrays.toString(arr));
```

#### 2.1.5 多维数组

```java
// 二维数组
int[][] matrix = new int[3][4];
int[][] matrix2 = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};

// 访问
int value = matrix[0][1];  // 第一行第二列

// 遍历
for (int i = 0; i < matrix.length; i++) {
    for (int j = 0; j < matrix[i].length; j++) {
        System.out.print(matrix[i][j] + " ");
    }
    System.out.println();
}
```

### 2.2 字符串

#### 2.2.1 String类的特性

- **不可变性**：String对象一旦创建就不能被修改
- **字符串常量池**：相同字面量的字符串共享同一对象

```java
String s1 = "Hello";
String s2 = "Hello";  // s1和s2指向同一对象（常量池）
String s3 = new String("Hello");  // 创建新对象
```

#### 2.2.2 字符串的创建

```java
// 方式1：字面量（推荐）
String str1 = "Hello";

// 方式2：构造方法
String str2 = new String("Hello");
char[] chars = {'H', 'e', 'l', 'l', 'o'};
String str3 = new String(chars);
```

#### 2.2.3 字符串的常用方法

| 方法 | 说明 | 示例 |
|------|------|------|
| length() | 获取长度 | str.length() |
| charAt(int) | 获取指定位置字符 | str.charAt(0) |
| substring(int) | 截取子串 | str.substring(2) |
| substring(int, int) | 截取子串 | str.substring(1, 3) |
| indexOf(String) | 查找字符/字符串 | str.indexOf("e") |
| contains(String) | 是否包含 | str.contains("el") |
| startsWith(String) | 是否以...开始 | str.startsWith("He") |
| endsWith(String) | 是否以...结束 | str.endsWith("lo") |
| replace(char, char) | 替换字符 | str.replace('l', 'L') |
| toUpperCase() | 转大写 | str.toUpperCase() |
| toLowerCase() | 转小写 | str.toLowerCase() |
| trim() | 去除首尾空格 | str.trim() |
| split(String) | 分割字符串 | str.split(",") |
| equals(Object) | 比较内容 | str1.equals(str2) |
| equalsIgnoreCase(String) | 忽略大小写比较 | str1.equalsIgnoreCase(str2) |

#### 2.2.4 字符串的比较

```java
String s1 = "Hello";
String s2 = "Hello";
String s3 = new String("Hello");

// == 比较引用
System.out.println(s1 == s2);  // true（常量池）
System.out.println(s1 == s3);  // false（不同对象）

// equals() 比较内容
System.out.println(s1.equals(s3));  // true
```

#### 2.2.5 StringBuilder和StringBuffer

当需要频繁修改字符串时，应使用`StringBuilder`或`StringBuffer`：

```java
// StringBuilder（非线程安全，性能更好）
StringBuilder sb = new StringBuilder();
sb.append("Hello");
sb.append(" World");
String result = sb.toString();

// StringBuffer（线程安全，性能稍差）
StringBuffer sb2 = new StringBuffer();
sb2.append("Hello");
```

**区别：**
- `String`：不可变，适合少量字符串操作
- `StringBuilder`：可变，非线程安全，适合单线程环境
- `StringBuffer`：可变，线程安全，适合多线程环境

---

## 3. 面向对象编程

### 3.1 类和对象

#### 3.1.1 类的定义

```java
public class Student {
    // 属性（成员变量）
    private String name;
    private int age;
    
    // 构造方法
    public Student() {
    }
    
    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    // 方法（成员方法）
    public void study() {
        System.out.println(name + "正在学习");
    }
    
    // getter和setter
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
}
```

#### 3.1.2 对象的创建和使用

```java
// 创建对象
Student student = new Student();
Student student2 = new Student("张三", 20);

// 使用对象
student.setName("李四");
String name = student.getName();
student.study();
```

### 3.2 封装

#### 3.2.1 封装的概念

封装是将数据和操作数据的方法绑定在一起，对外隐藏实现细节，只提供必要的接口。

#### 3.2.2 访问修饰符

| 修饰符 | 同一类 | 同一包 | 子类 | 其他包 |
|--------|--------|--------|------|--------|
| private | ✓ | ✗ | ✗ | ✗ |
| default | ✓ | ✓ | ✗ | ✗ |
| protected | ✓ | ✓ | ✓ | ✗ |
| public | ✓ | ✓ | ✓ | ✓ |

```java
public class Student {
    private String name;  // 私有属性，只能在本类中访问
    protected int age;    // 受保护属性，子类可以访问
    String id;            // 包访问权限
    public String school; // 公开属性
}
```

### 3.3 继承

#### 3.3.1 继承的概念

继承是面向对象的一个重要特性，子类可以继承父类的属性和方法。

```java
// 父类
public class Person {
    protected String name;
    protected int age;
    
    public void introduce() {
        System.out.println("我是" + name);
    }
}

// 子类
public class Student extends Person {
    private String studentId;
    
    // 方法重写
    @Override
    public void introduce() {
        super.introduce();  // 调用父类方法
        System.out.println("学号：" + studentId);
    }
}
```

#### 3.3.2 super关键字

- `super`：指向父类对象
- `super()`：调用父类构造方法
- `super.method()`：调用父类方法

#### 3.3.3 方法重写（Override）

子类可以重写父类的方法：

```java
@Override
public void introduce() {
    // 重写父类方法
}
```

**规则：**
- 方法名、参数列表必须相同
- 返回类型可以是子类类型（协变返回类型）
- 访问权限不能比父类更严格
- 不能重写`private`、`final`、`static`方法

### 3.4 多态

#### 3.4.1 多态的概念

多态是指同一个方法调用，根据对象的不同而有不同的行为。

#### 3.4.2 方法重载（Overload）

同一个类中可以有多个同名方法，但参数列表不同：

```java
public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }
    
    public double add(double a, double b) {
        return a + b;
    }
    
    public int add(int a, int b, int c) {
        return a + b + c;
    }
}
```

**规则：**
- 方法名相同
- 参数列表不同（类型、个数、顺序）
- 返回类型可以不同
- 与访问修饰符无关

#### 3.4.3 向上转型和向下转型

```java
// 向上转型（自动）
Person person = new Student();

// 向下转型（需要强制转换）
if (person instanceof Student) {
    Student student = (Student) person;
}
```

### 3.5 static关键字

#### 3.5.1 静态变量

属于类，所有对象共享：

```java
public class Counter {
    private static int count = 0;  // 静态变量
    
    public static int getCount() {
        return count;
    }
}

// 使用
int count = Counter.getCount();  // 通过类名访问
```

#### 3.5.2 静态方法

属于类，不能访问非静态成员：

```java
public class MathUtils {
    public static int max(int a, int b) {
        return a > b ? a : b;
    }
}

// 使用
int max = MathUtils.max(10, 20);
```

#### 3.5.3 静态代码块

在类加载时执行：

```java
public class MyClass {
    static {
        System.out.println("静态代码块执行");
    }
}
```

### 3.6 final关键字

- `final`修饰变量：常量，不能修改
- `final`修饰方法：不能被子类重写
- `final`修饰类：不能被继承

```java
final class FinalClass {
    final int FINAL_VAR = 100;
    
    final void finalMethod() {
        // 不能重写
    }
}
```

---

## 4. 接口、抽象类、内部类

### 4.1 接口

#### 4.1.1 接口的定义

```java
public interface Drawable {
    // 常量（默认public static final）
    String COLOR = "BLACK";
    
    // 抽象方法（默认public abstract）
    void draw();
    
    // 默认方法（Java 8+）
    default void printInfo() {
        System.out.println("这是一个可绘制的对象");
    }
    
    // 静态方法（Java 8+）
    static void showVersion() {
        System.out.println("版本 1.0");
    }
}
```

#### 4.1.2 接口的实现

```java
public class Circle implements Drawable {
    @Override
    public void draw() {
        System.out.println("画一个圆形");
    }
}
```

#### 4.1.3 多实现

Java支持多实现：

```java
public class Circle implements Drawable, Colorable {
    // 实现多个接口的方法
}
```

### 4.2 抽象类

#### 4.2.1 抽象类的定义

```java
public abstract class Shape {
    protected String name;
    
    // 抽象方法
    public abstract double calculateArea();
    
    // 普通方法
    public void printName() {
        System.out.println("形状名称：" + name);
    }
}
```

#### 4.2.2 抽象类的继承

```java
public class Circle extends Shape {
    private double radius;
    
    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }
}
```

### 4.3 接口vs抽象类

| 特性 | 接口 | 抽象类 |
|------|------|--------|
| 继承 | 多实现 | 单继承 |
| 方法 | 只能有抽象方法（Java 8前） | 可以有抽象和普通方法 |
| 变量 | 只能是常量 | 可以有各种变量 |
| 构造方法 | 不能有 | 可以有 |
| 使用场景 | 定义行为契约 | 有部分实现的类层次结构 |

### 4.4 内部类

#### 4.4.1 成员内部类

```java
public class Outer {
    private String outerField = "外部类字段";
    
    class Inner {
        public void accessOuter() {
            System.out.println(outerField);  // 可以访问外部类成员
        }
    }
}
```

#### 4.4.2 静态内部类

```java
public class Outer {
    private static String outerField = "外部类静态字段";
    
    static class StaticInner {
        public void accessOuter() {
            System.out.println(outerField);
        }
    }
}
```

#### 4.4.3 局部内部类

```java
public class Outer {
    public void method() {
        class LocalInner {
            public void print() {
                System.out.println("局部内部类");
            }
        }
        LocalInner local = new LocalInner();
        local.print();
    }
}
```

#### 4.4.4 匿名内部类

```java
Drawable drawable = new Drawable() {
    @Override
    public void draw() {
        System.out.println("匿名内部类实现");
    }
};
```

---

## 5. 枚举和注解

### 5.1 枚举

#### 5.1.1 枚举的定义

```java
public enum Weekday {
    MONDAY("星期一"),
    TUESDAY("星期二"),
    WEDNESDAY("星期三"),
    THURSDAY("星期四"),
    FRIDAY("星期五"),
    SATURDAY("星期六"),
    SUNDAY("星期日");
    
    private final String chineseName;
    
    Weekday(String chineseName) {
        this.chineseName = chineseName;
    }
    
    public String getChineseName() {
        return chineseName;
    }
}
```

#### 5.1.2 枚举的使用

```java
Weekday day = Weekday.MONDAY;
System.out.println(day.getChineseName());

// 遍历枚举
for (Weekday weekday : Weekday.values()) {
    System.out.println(weekday);
}

// switch中使用
switch (day) {
    case MONDAY:
        System.out.println("周一");
        break;
    // ...
}
```

### 5.2 注解

#### 5.2.1 内置注解

- `@Override`：表示方法重写
- `@Deprecated`：表示已过时
- `@SuppressWarnings`：抑制警告
- `@SafeVarargs`：安全可变参数
- `@FunctionalInterface`：函数式接口

#### 5.2.2 自定义注解

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {
    String value() default "";
    int count() default 1;
}

// 使用
@MyAnnotation(value = "测试", count = 3)
public void testMethod() {
}
```

#### 5.2.3 元注解

- `@Target`：指定注解可以应用的位置
- `@Retention`：指定注解的保留策略
- `@Documented`：文档化
- `@Inherited`：可继承
- `@Repeatable`：可重复

---

## 6. 集合框架

### 6.1 集合框架概述

Java集合框架主要包含以下接口和类：

- **Collection接口**：List、Set、Queue
- **Map接口**：HashMap、TreeMap等
- **工具类**：Collections、Arrays

### 6.2 List接口

#### 6.2.1 ArrayList

动态数组，适合随机访问：

```java
List<String> list = new ArrayList<>();
list.add("Java");
list.add("Python");
list.get(0);  // 获取元素
list.remove(0);  // 删除元素
```

#### 6.2.2 LinkedList

双向链表，适合插入和删除：

```java
LinkedList<String> list = new LinkedList<>();
list.addFirst("First");
list.addLast("Last");
list.removeFirst();
```

### 6.3 Set接口

#### 6.3.1 HashSet

无序、不重复，基于哈希表：

```java
Set<String> set = new HashSet<>();
set.add("Java");
set.add("Java");  // 重复元素不会被添加
```

#### 6.3.2 TreeSet

有序、不重复，基于红黑树：

```java
Set<Integer> set = new TreeSet<>();
set.add(3);
set.add(1);
set.add(2);
// 自动排序：1, 2, 3
```

### 6.4 Map接口

#### 6.4.1 HashMap

键值对映射，无序：

```java
Map<String, Integer> map = new HashMap<>();
map.put("Java", 100);
map.get("Java");  // 获取值
map.containsKey("Java");  // 判断是否包含键
```

#### 6.4.2 TreeMap

有序的键值对映射：

```java
Map<String, Integer> map = new TreeMap<>();
// 按键的自然顺序排序
```

### 6.5 泛型

#### 6.5.1 泛型的使用

```java
List<String> list = new ArrayList<String>();
// Java 7+可以省略后面的类型
List<String> list = new ArrayList<>();
```

#### 6.5.2 泛型通配符

```java
// ? 任意类型
List<?> list;

// ? extends T 上界通配符
List<? extends Number> list;

// ? super T 下界通配符
List<? super Integer> list;
```

---

## 7. I/O流

### 7.1 流的分类

- **按方向**：输入流（InputStream/Reader）、输出流（OutputStream/Writer）
- **按数据单位**：字节流、字符流
- **按功能**：节点流、处理流（缓冲流、转换流等）

### 7.2 字节流

#### 7.2.1 FileInputStream

```java
try (FileInputStream fis = new FileInputStream("file.txt")) {
    int data;
    while ((data = fis.read()) != -1) {
        // 处理数据
    }
}
```

#### 7.2.2 FileOutputStream

```java
try (FileOutputStream fos = new FileOutputStream("file.txt")) {
    fos.write("Hello".getBytes());
}
```

### 7.3 字符流

#### 7.3.1 FileReader

```java
try (FileReader reader = new FileReader("file.txt")) {
    int data;
    while ((data = reader.read()) != -1) {
        // 处理字符
    }
}
```

#### 7.3.2 FileWriter

```java
try (FileWriter writer = new FileWriter("file.txt")) {
    writer.write("Hello");
}
```

### 7.4 缓冲流

提高I/O效率：

```java
try (BufferedReader reader = new BufferedReader(new FileReader("file.txt"));
     BufferedWriter writer = new BufferedWriter(new FileWriter("output.txt"))) {
    String line;
    while ((line = reader.readLine()) != null) {
        writer.write(line);
        writer.newLine();
    }
}
```

### 7.5 序列化

```java
// 序列化
class Student implements Serializable {
    private static final long serialVersionUID = 1L;
    // ...
}

try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("student.dat"))) {
    oos.writeObject(student);
}

// 反序列化
try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream("student.dat"))) {
    Student student = (Student) ois.readObject();
}
```

---

## 8. 多线程

### 8.1 线程的创建

#### 8.1.1 继承Thread类

```java
class MyThread extends Thread {
    @Override
    public void run() {
        // 线程执行的任务
    }
}

// 使用
MyThread thread = new MyThread();
thread.start();
```

#### 8.1.2 实现Runnable接口

```java
class MyRunnable implements Runnable {
    @Override
    public void run() {
        // 线程执行的任务
    }
}

// 使用
Thread thread = new Thread(new MyRunnable());
thread.start();
```

#### 8.1.3 使用Lambda表达式

```java
Thread thread = new Thread(() -> {
    // 线程执行的任务
});
thread.start();
```

### 8.2 线程同步

#### 8.2.1 synchronized关键字

```java
// 同步方法
public synchronized void method() {
    // 临界区代码
}

// 同步代码块
synchronized (obj) {
    // 临界区代码
}
```

#### 8.2.2 Lock接口

```java
ReentrantLock lock = new ReentrantLock();
lock.lock();
try {
    // 临界区代码
} finally {
    lock.unlock();
}
```

### 8.3 线程通信

```java
synchronized (obj) {
    obj.wait();  // 等待
    obj.notify();  // 唤醒
    obj.notifyAll();  // 唤醒所有
}
```

### 8.4 线程池

```java
ExecutorService executor = Executors.newFixedThreadPool(5);
executor.execute(() -> {
    // 任务
});
executor.shutdown();
```

---

## 9. 异常处理和反射

### 9.1 异常分类

- **Checked Exception**：编译时异常，必须处理
- **Unchecked Exception**：运行时异常，可以不处理

### 9.2 异常处理

```java
try {
    // 可能抛出异常的代码
} catch (ExceptionType e) {
    // 处理异常
} finally {
    // 总是执行的代码
}
```

### 9.3 反射

#### 9.3.1 获取Class对象

```java
Class<?> clazz1 = String.class;
Class<?> clazz2 = "hello".getClass();
Class<?> clazz3 = Class.forName("java.lang.String");
```

#### 9.3.2 创建对象

```java
Constructor<?> constructor = clazz.getConstructor(String.class);
Object obj = constructor.newInstance("Hello");
```

#### 9.3.3 调用方法

```java
Method method = clazz.getMethod("toUpperCase");
Object result = method.invoke(str);
```

---

## 10. Lambda表达式和Stream API

### 10.1 Lambda表达式

#### 10.1.1 语法

```java
(参数列表) -> { 方法体 }
```

#### 10.1.2 示例

```java
// 无参数
Runnable r = () -> System.out.println("Hello");

// 单参数
Consumer<String> c = s -> System.out.println(s);

// 多参数
BinaryOperator<Integer> add = (a, b) -> a + b;
```

### 10.2 函数式接口

- `Predicate<T>`：断言，返回boolean
- `Function<T, R>`：函数，接受T返回R
- `Consumer<T>`：消费者，接受T无返回值
- `Supplier<T>`：供应者，无参数返回T

### 10.3 Stream API

#### 10.3.1 创建Stream

```java
List<String> list = Arrays.asList("a", "b", "c");
Stream<String> stream = list.stream();
```

#### 10.3.2 中间操作

- `filter`：过滤
- `map`：转换
- `sorted`：排序
- `distinct`：去重

#### 10.3.3 终止操作

- `collect`：收集
- `forEach`：遍历
- `reduce`：归约
- `count`：计数

```java
List<String> result = list.stream()
    .filter(s -> s.length() > 3)
    .map(String::toUpperCase)
    .collect(Collectors.toList());
```

---

## 总结

本文档涵盖了Java基础阶段的所有重要知识点。学习建议：

1. **理论与实践结合**：看完理论知识后立即实践
2. **循序渐进**：按照章节顺序学习
3. **多做练习**：完成练习代码中的所有TODO
4. **理解原理**：不仅要会写，更要理解为什么
5. **持续复习**：定期回顾已学知识

**祝学习顺利！**

