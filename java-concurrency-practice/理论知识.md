# Java并发编程理论知识

本文档用于整理并发编程的核心概念与常见工具，作为本模块代码练习的配套笔记。

---

## 目录

1. [并发与并行、进程与线程](#1-并发与并行进程与线程)
2. [线程安全三要素](#2-线程安全三要素)
3. [Java内存模型（JMM）与 happens-before](#3-java内存模型jmm与-happens-before)
4. [`volatile`](#4-volatile)
5. [`synchronized` 与监视器锁](#5-synchronized-与监视器锁)
6. [`Lock` 与 `ReentrantLock`](#6-lock-与-reentrantlock)
7. [CAS 与原子类](#7-cas-与原子类)
8. [AQS 简述](#8-aqs-简述)
9. [线程池（Executor）](#9-线程池executor)
10. [`Future` 与 `CompletableFuture`](#10-future-与-completablefuture)
11. [并发工具类：CountDownLatch/Semaphore/CyclicBarrier](#11-并发工具类countdownlatchsemaphorecyclicbarrier)
12. [`ThreadLocal`](#12-threadlocal)
13. [虚拟线程（Virtual Thread）入门](#13-虚拟线程virtual-thread入门)

---

## 1. 并发与并行、进程与线程

- **并发（Concurrency）**：在同一时间段内处理多个任务（任务交错推进）。
- **并行（Parallelism）**：在同一时刻真正同时执行多个任务（多核同时跑）。

- **进程**：资源分配的基本单位（独立地址空间）。
- **线程**：CPU 调度的基本单位（共享进程资源）。

 并发编程的本质是：
 - 提升吞吐与响应（尤其是 I/O 场景）
 - 但会引入共享状态、可见性与时序的不确定性

 ### 1.1 常见并发收益与代价

 - **收益**
   - I/O 密集：并发可以显著提升吞吐与响应（线程在等待 I/O 时让出 CPU）。
   - 多核 CPU：并行可以把可拆分的计算任务分摊到多个核心。
 - **代价**
   - 共享状态带来的竞态条件（Race Condition）。
   - 上下文切换成本、锁竞争成本。
   - 排查难度：问题可能“偶现”，与时序、机器负载有关。

 ### 1.2 线程的生命周期与状态（Java 视角）

 - **NEW**：创建但未 `start()`。
 - **RUNNABLE**：就绪或运行中（Java 将就绪与运行合并为 RUNNABLE）。
 - **BLOCKED**：等待进入 `synchronized` 监视器锁。
 - **WAITING**：无限期等待（如 `Object.wait()`、`Thread.join()`）。
 - **TIMED_WAITING**：超时等待（如 `sleep`、带超时的 `wait/join`）。
 - **TERMINATED**：执行结束。

## 2. 线程安全三要素

线程安全问题通常来自以下三类：

1. **原子性（Atomicity）**
   - 一个操作要么全部完成，要么完全不做。
   - 例如 `i++` 不是原子操作（读-改-写三步）。

2. **可见性（Visibility）**
   - 一个线程对共享变量的修改，其他线程能否“及时”看到。
   - 线程可能使用工作内存/寄存器缓存旧值。

3. **有序性（Ordering）**
   - 编译器/CPU 可能对指令重排序，只要单线程语义不变。
   - 多线程下重排序可能破坏你的假设。

 ### 2.1 竞态条件示例（为什么 `i++` 不安全）

 `i++` 在机器层面会分解为：
 - 读取 `i`
 - `+1`
 - 写回 `i`

 多线程同时执行会出现“丢失更新”。

 你可以对比本模块的三个计数器 demo：
 - `SynchronizedCounterDemo`
 - `ReentrantLockCounterDemo`
 - `AtomicCounterDemo`

 ### 2.2 线程安全的目标不是“加锁越多越好”

 常见目标包括：
 - **正确性**：不破坏不变量（invariant），不会读到中间态。
 - **性能**：避免过大临界区导致串行化。
 - **可维护性**：锁对象与锁顺序清晰，尽量减少隐式共享。

## 3. Java内存模型（JMM）与 happens-before

JMM 用于规定：
- 共享变量何时必须从主内存读取
- 何时必须写回主内存
- 什么同步手段能建立线程间的“可见性与有序性”

### happens-before 规则（常用）

- **程序次序规则**：同一线程内，前面的操作 happens-before 后面的操作。
- **监视器锁规则**：对同一把锁的 `unlock` happens-before 后续的 `lock`。
- **volatile 规则**：对一个 `volatile` 变量的写 happens-before 后续对该变量的读。
- **线程启动规则**：`Thread.start()` happens-before 线程内的所有操作。
- **线程终止规则**：线程内操作 happens-before 另一个线程成功 `join()` 返回。

理解 happens-before 的意义：
- 它不是“时间先后”，而是“内存可见性与禁止重排序”的约束关系。

 ### 3.1 为什么会有“可见性”问题

 现代 CPU 为了性能会使用多级缓存，编译器也会做优化。
 在没有同步手段时：
 - 一个线程写入的值可能仍停留在缓存/寄存器中
 - 另一个线程读取到的仍是旧值

 ### 3.2 happens-before 的实用理解

 当你在代码里建立了某种 happens-before 关系，你得到的是：
 - **前置操作的结果对后置操作可见**
 - **禁止相关重排序**（并不是完全禁止所有重排序）

 常用推理方式：
 - 线程内：顺序执行
 - 线程间：用 `volatile` / 锁 / `join` / 线程安全容器等建立可见性

## 4. `volatile`

`volatile` 的核心作用：
- **保证可见性**：写入会刷新到主内存，读取会从主内存获取。
- **保证有序性（部分）**：通过内存屏障约束重排序。

`volatile` 不保证：
- **复合操作的原子性**：例如 `count++` 仍然不是原子的。

典型适用场景：
- 状态标记（停止线程、开关配置）
- 双重检查锁（DCL）中 `instance` 需要 `volatile`

 ### 4.1 `volatile` 能解决什么，不能解决什么

 - **能解决**
   - 可见性（一个线程写入，其他线程随后读取能看到最新值）
   - 与该变量相关的有序性（通过内存屏障限制重排序）
 - **不能解决**
   - 复合操作的原子性（如 `count++`）
   - 更复杂的不变量维护（例如“先检查再执行”的竞态）

 ### 4.2 DCL（Double-Checked Locking）为什么需要 `volatile`

 在 DCL 单例中，如果没有 `volatile`，可能出现：
 - 引用已经赋值
 - 但对象内部还没完全初始化
 从而导致其他线程拿到“半初始化对象”。

 ### 4.3 经验法则

 - 需要“一个线程写、多线程读”的状态标记：优先考虑 `volatile`
 - 需要对共享变量做复合更新：考虑 `synchronized`/`Lock`/原子类/并发容器

## 5. `synchronized` 与监视器锁

`synchronized` 作用：
- **互斥**：同一时刻只有一个线程进入临界区
- **可见性**：进入/退出临界区时会建立 happens-before

使用形式：
- 修饰实例方法（锁对象是 `this`）
- 修饰静态方法（锁对象是 `Class` 对象）
- 修饰代码块（锁对象是括号里的对象）

实践建议：
- 锁粒度尽量小，但避免过度拆分造成复杂度上升
- 临界区内不要做慢 I/O（容易放大锁竞争）

 ### 5.1 `synchronized` 示例代码（来自本模块）

 下面这段代码对应：`com.struct.concurrency.demo.SynchronizedCounterDemo`

 ```java
 package com.struct.concurrency.demo;
 
 public class SynchronizedCounterDemo {
 
     private static final class Counter {
         private int value;
 
         public synchronized void increment() {
             value++;
         }
 
         public synchronized int get() {
             return value;
         }
     }
 
     public static void run() throws InterruptedException {
         Counter counter = new Counter();
 
         int threads = 8;
         int loops = 50_000;
 
         Thread[] workers = new Thread[threads];
         for (int i = 0; i < threads; i++) {
             workers[i] = new Thread(() -> {
                 for (int j = 0; j < loops; j++) {
                     counter.increment();
                 }
             }, "sync-worker-" + i);
         }
 
         for (Thread t : workers) {
             t.start();
         }
         for (Thread t : workers) {
             t.join();
         }
 
         int expected = threads * loops;
         System.out.println("expected=" + expected + ", actual=" + counter.get());
     }
 }
 ```

 ### 5.2 锁对象与锁粒度

 - `synchronized (obj)` 的锁对象是 `obj` 的监视器（monitor）
 - 不同锁对象互不影响
 - 锁粒度越粗越简单但并发度越低；越细并发度越高但复杂度越高

 ### 5.3 `wait/notify` 与锁

 - `wait/notify/notifyAll` 必须在持有同一把监视器锁时调用
 - `wait()` 会释放监视器锁并进入等待队列
 - `notify()` 唤醒一个等待线程，但被唤醒线程仍需重新竞争锁

## 6. `Lock` 与 `ReentrantLock`

`ReentrantLock` 相对 `synchronized` 常见优势：
- 可中断获取锁（`lockInterruptibly`）
- 可尝试获取锁（`tryLock`）
- 可选公平锁
- 支持多个条件队列（`newCondition`）

但它需要你显式释放锁：
- 必须 `try/finally` 保证 `unlock()`

 ### 6.1 `ReentrantLock` 示例代码（来自本模块）

 下面这段代码对应：`com.struct.concurrency.demo.ReentrantLockCounterDemo`

 ```java
 package com.struct.concurrency.demo;
 
 import java.util.concurrent.locks.ReentrantLock;
 
 public class ReentrantLockCounterDemo {
 
     private static final class Counter {
         private final ReentrantLock lock = new ReentrantLock();
         private int value;
 
         public void increment() {
             lock.lock();
             try {
                 value++;
             } finally {
                 lock.unlock();
             }
         }
 
         public int get() {
             lock.lock();
             try {
                 return value;
             } finally {
                 lock.unlock();
             }
         }
     }
 
     public static void run() throws InterruptedException {
         Counter counter = new Counter();
 
         int threads = 8;
         int loops = 50_000;
 
         Thread[] workers = new Thread[threads];
         for (int i = 0; i < threads; i++) {
             workers[i] = new Thread(() -> {
                 for (int j = 0; j < loops; j++) {
                     counter.increment();
                 }
             }, "lock-worker-" + i);
         }
 
         for (Thread t : workers) {
             t.start();
         }
         for (Thread t : workers) {
             t.join();
         }
 
         int expected = threads * loops;
         System.out.println("expected=" + expected + ", actual=" + counter.get());
     }
 }
 ```

 ### 6.2 何时倾向 `ReentrantLock`

 - 你需要 `tryLock` 做“避免死锁/超时退避”
 - 你需要可中断地等待锁（响应取消）
 - 你需要多个条件队列（`Condition`）来表达更复杂的等待/通知逻辑

## 7. CAS 与原子类

**CAS（Compare-And-Swap）**：
- 通过比较内存中的旧值与期望值，若相等则更新为新值
- 在硬件层面提供原子指令

JUC 原子类（如 `AtomicInteger`）基于 CAS：
- `incrementAndGet` 通过自旋 + CAS 实现无锁更新

CAS 的典型问题：
- **ABA 问题**：值从 A 变 B 又变回 A，CAS 可能误判“没变”。
  - 解决：版本号（`AtomicStampedReference`）
- **自旋开销**：竞争激烈时自旋会浪费 CPU

 ### 7.1 `AtomicInteger` 示例代码（来自本模块）

 下面这段代码对应：`com.struct.concurrency.demo.AtomicCounterDemo`

 ```java
 package com.struct.concurrency.demo;
 
 import java.util.concurrent.atomic.AtomicInteger;
 
 public class AtomicCounterDemo {
 
     public static void run() throws InterruptedException {
         AtomicInteger counter = new AtomicInteger(0);
 
         int threads = 8;
         int loops = 50_000;
 
         Thread[] workers = new Thread[threads];
         for (int i = 0; i < threads; i++) {
             workers[i] = new Thread(() -> {
                 for (int j = 0; j < loops; j++) {
                     counter.incrementAndGet();
                 }
             }, "atomic-worker-" + i);
         }
 
         for (Thread t : workers) {
             t.start();
         }
         for (Thread t : workers) {
             t.join();
         }
 
         int expected = threads * loops;
         System.out.println("expected=" + expected + ", actual=" + counter.get());
     }
 }
 ```

 ### 7.2 什么时候原子类不够用

 - 你需要“多个字段一起更新”维持不变量
 - 你需要“先检查再更新”的复合逻辑
 这类场景更适合：
 - 用锁保护临界区
 - 或把状态收敛为单一原子引用（如 `AtomicReference<State>`）

## 8. AQS 简述

AQS（AbstractQueuedSynchronizer）是很多同步器的基础：
- `ReentrantLock`
- `Semaphore`
- `CountDownLatch`
- `ReentrantReadWriteLock`

核心思路：
- 用一个 `state` 表示同步状态
- 竞争失败的线程进入 FIFO 等待队列

 ### 8.1 AQS 的两个常见模式

 - **独占模式（Exclusive）**
   - 典型：`ReentrantLock`
 - **共享模式（Shared）**
   - 典型：`CountDownLatch`、`Semaphore`

 对学习者来说，掌握到下面这个层级通常就够用了：
 - AQS 提供了“排队 + 阻塞/唤醒”的通用框架
 - 具体同步器只需要定义如何修改 `state`（获取/释放）

## 9. 线程池（Executor）

使用线程池的好处：
- 避免频繁创建/销毁线程
- 统一管理并发度与资源
- 提供队列、拒绝策略、监控等能力

关键参数（以 `ThreadPoolExecutor` 为例）：
- `corePoolSize` / `maximumPoolSize`
- `workQueue`
- `keepAliveTime`
- `RejectedExecutionHandler`

实践建议：
- 区分 CPU 密集与 IO 密集任务
- 明确队列是否有界，避免无界队列导致内存风险

 ### 9.1 `ExecutorService` 示例代码（来自本模块）

 下面这段代码对应：`com.struct.concurrency.demo.ExecutorServiceDemo`

 ```java
 package com.struct.concurrency.demo;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 
 public class ExecutorServiceDemo {
 
     public static void run() throws ExecutionException, InterruptedException {
         ExecutorService pool = Executors.newFixedThreadPool(4);
 
         try {
             List<Callable<Integer>> tasks = new ArrayList<>();
             for (int i = 0; i < 10; i++) {
                 int idx = i;
                 tasks.add(() -> {
                     TimeUnit.MILLISECONDS.sleep(50L);
                     return idx * idx;
                 });
             }
 
             List<Future<Integer>> futures = new ArrayList<>();
             for (Callable<Integer> task : tasks) {
                 futures.add(pool.submit(task));
             }
 
             int sum = 0;
             for (Future<Integer> f : futures) {
                 sum += f.get();
             }
 
             System.out.println("sum=" + sum);
         } finally {
             pool.shutdown();
             pool.awaitTermination(5, TimeUnit.SECONDS);
         }
     }
 }
 ```

 ### 9.2 线程池使用的几个“坑点”

 - `Future#get()` 是阻塞的：如果在任务提交线程里大量 `get()`，会把并发“串回去”。
 - 线程池必须关闭：否则进程可能因为非守护线程未退出而“挂着”。
 - 不要在任务里再提交大量任务并同步等待（容易导致线程池饥饿/死锁）。

## 10. `Future` 与 `CompletableFuture`

- `Future`：
  - 能获取结果、取消任务
  - 但组合能力弱，常见问题是 `get()` 阻塞

- `CompletableFuture`：
  - 提供链式编排（`thenApply/thenCompose/thenCombine`）
  - 可以更自然地表达异步依赖关系

实践建议：
- 异步链中注意异常处理（`exceptionally/handle/whenComplete`）
- 注意默认线程池（`ForkJoinPool.commonPool`）的影响

 ### 10.1 `CompletableFuture` 示例代码（来自本模块）

 下面这段代码对应：`com.struct.concurrency.demo.CompletableFutureDemo`

 ```java
 package com.struct.concurrency.demo;
 
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
 
 public class CompletableFutureDemo {
 
     public static void run() throws ExecutionException, InterruptedException {
         CompletableFuture<Integer> f1 = CompletableFuture.supplyAsync(() -> {
             sleep(100);
             return 20;
         });
 
         CompletableFuture<Integer> f2 = CompletableFuture.supplyAsync(() -> {
             sleep(150);
             return 22;
         });
 
         CompletableFuture<Integer> result = f1.thenCombine(f2, Integer::sum);
         System.out.println("result=" + result.get());
     }
 
     private static void sleep(long ms) {
         try {
             TimeUnit.MILLISECONDS.sleep(ms);
         } catch (InterruptedException e) {
             Thread.currentThread().interrupt();
         }
     }
 }
 ```

 ### 10.2 常用组合方式速查

 - `thenApply`：对结果做映射
 - `thenCompose`：扁平化（返回另一个 future）
 - `thenCombine`：两个 future 都完成后合并
 - `allOf`：等待多个 future 全部完成
 - `anyOf`：任一完成就继续

## 11. 并发工具类：CountDownLatch/Semaphore/CyclicBarrier

- **CountDownLatch**：
  - 一个或多个线程等待一组事件完成
  - 计数归零后不可复用

- **Semaphore**：
  - 限流/控制并发数（资源许可证）

- **CyclicBarrier**：
  - 一组线程互相等待到达屏障点
  - 可复用（循环）

 ### 11.1 `CountDownLatch` 示例代码（来自本模块）

 下面这段代码对应：`com.struct.concurrency.demo.CountDownLatchDemo`

 ```java
 package com.struct.concurrency.demo;
 
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 
 public class CountDownLatchDemo {
 
     public static void run() throws InterruptedException {
         CountDownLatch latch = new CountDownLatch(3);
 
         for (int i = 0; i < 3; i++) {
             int idx = i;
             Thread.ofVirtual().name("latch-worker-" + i).start(() -> {
                 try {
                     TimeUnit.MILLISECONDS.sleep(100L + idx * 50L);
                     System.out.println("done: " + Thread.currentThread().getName());
                 } catch (InterruptedException e) {
                     Thread.currentThread().interrupt();
                 } finally {
                     latch.countDown();
                 }
             });
         }
 
         latch.await();
         System.out.println("all done");
     }
 }
 ```

 ### 11.2 选择工具类的经验

 - “等一组任务都完成再继续”：`CountDownLatch`
 - “限制并发数量/限流”：`Semaphore`
 - “一组线程对齐到同一步再同时继续”：`CyclicBarrier`

## 12. `ThreadLocal`

`ThreadLocal` 的意义：
- 给每个线程提供“变量副本”，避免共享

常见用途：
- 线程内上下文（traceId、用户信息）
- 线程内缓存

注意事项：
- 在线程池场景要谨慎：线程会复用，`ThreadLocal` 值可能“串号”
- 用完建议 `remove()`，避免潜在内存泄漏

 ### 12.1 `ThreadLocal` 示例代码（来自本模块）

 下面这段代码对应：`com.struct.concurrency.demo.ThreadLocalDemo`

 ```java
 package com.struct.concurrency.demo;
 
 public class ThreadLocalDemo {
 
     private static final ThreadLocal<Integer> LOCAL = ThreadLocal.withInitial(() -> 0);
 
     public static void run() throws InterruptedException {
         Thread t1 = Thread.ofVirtual().name("tl-1").start(() -> {
             LOCAL.set(100);
             System.out.println(Thread.currentThread().getName() + " local=" + LOCAL.get());
         });
 
         Thread t2 = Thread.ofVirtual().name("tl-2").start(() -> {
             LOCAL.set(200);
             System.out.println(Thread.currentThread().getName() + " local=" + LOCAL.get());
         });
 
         t1.join();
         t2.join();
 
         System.out.println("main local=" + LOCAL.get());
     }
 }
 ```

 ### 12.2 为什么线程池里更容易出问题

 线程池会复用线程：
 - 你以为“请求结束线程就销毁”，但线程实际上会继续执行下一个任务
 - 如果不 `remove()`，上一次任务写入的 `ThreadLocal` 值可能影响下一次任务

## 13. 虚拟线程（Virtual Thread）入门

虚拟线程特点（相对平台线程）：
- 创建成本更低，适合大量 I/O 阻塞型任务
- 编程模型仍然是“一个请求一个线程”的同步写法

实践建议：
- 优先用于 I/O 密集任务
- 关注阻塞点是否是“可挂起”的（JDK 对常见阻塞点做了适配）
- 不要把虚拟线程当成“无限资源”，仍要做限流与超时控制

 ### 13.1 虚拟线程示例代码（来自本模块）

 下面这段代码对应：`com.struct.concurrency.demo.ThreadCreationDemo`

 ```java
 package com.struct.concurrency.demo;
 
 public class ThreadCreationDemo {
 
     public static void run() throws InterruptedException {
         Thread t1 = new Thread(() -> System.out.println("platform thread: " + Thread.currentThread()), "platform-demo");
         t1.start();
         t1.join();
 
         Thread t2 = Thread.ofVirtual().name("virtual-demo").start(() -> System.out.println("virtual thread: " + Thread.currentThread()));
         t2.join();
     }
 }
 ```

 ### 13.2 使用虚拟线程的实践建议

 - 虚拟线程适合“多等待、少计算”的任务模型（例如大量网络调用）
 - 仍然需要超时、限流与资源保护（连接数、下游容量）
 - 避免在虚拟线程里长时间持有 `synchronized` 锁做阻塞 I/O（会放大调度问题）
