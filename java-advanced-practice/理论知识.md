# Java进阶阶段理论知识

本文档涵盖Java进阶阶段（第二部分）的所有理论知识，是深入理解Java高级特性的理论基础。

---

## 目录

1. [JVM深入](#1-jvm深入)
2. [并发编程深入](#2-并发编程深入)
3. [设计模式](#3-设计模式)

---

## 1. JVM深入

### 1.1 JVM内存模型

#### 1.1.1 JVM内存区域划分

Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域：

**1. 程序计数器（Program Counter Register）**

- **作用**：记录当前线程执行的字节码指令地址
- **特点**：
  - 线程私有，每个线程都有独立的程序计数器
  - 唯一不会发生`OutOfMemoryError`的区域
  - 如果执行的是Native方法，计数器值为空（Undefined）

**2. Java虚拟机栈（Java Virtual Machine Stack）**

- **作用**：存储局部变量表、操作数栈、动态链接、方法返回地址
- **特点**：
  - 线程私有，生命周期与线程相同
  - 每个方法执行时会创建一个栈帧（Stack Frame）
  - 栈帧包含：
    - **局部变量表**：存放方法参数和方法内部定义的局部变量
    - **操作数栈**：方法执行过程中的计算工作区域
    - **动态链接**：指向运行时常量池的方法引用
    - **方法返回地址**：方法正常退出或异常退出的地址
- **异常**：
  - `StackOverflowError`：线程请求的栈深度大于虚拟机允许的深度
  - `OutOfMemoryError`：虚拟机栈扩展时无法申请到足够的内存

**3. 本地方法栈（Native Method Stack）**

- **作用**：为Native方法服务
- **特点**：与虚拟机栈类似，但服务于Native方法
- **注意**：HotSpot虚拟机将本地方法栈和虚拟机栈合二为一

**4. Java堆（Java Heap）**

- **作用**：存放对象实例和数组
- **特点**：
  - 线程共享，生命周期与虚拟机相同
  - 最大的一块内存区域
  - 垃圾收集器管理的主要区域（"GC堆"）
- **分区**：
  - **新生代（Young Generation）**
    - Eden区：新对象分配的主要区域
    - Survivor0/Survivor1：存活对象在Minor GC后移动到这里
    - 比例：Eden : Survivor0 : Survivor1 = 8:1:1
  - **老年代（Old Generation）**
    - 长期存活的对象最终会进入老年代
- **异常**：`OutOfMemoryError: Java heap space`

**5. 方法区（Method Area）/ 元空间（Metaspace）**

- **作用**：存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码
- **演变**：
  - **Java 7之前**：永久代（PermGen），是堆的一部分
  - **Java 8+**：元空间（Metaspace），使用本地内存
- **组成部分**：
  - **运行时常量池**（Runtime Constant Pool）
    - 方法区的一部分
    - 存放编译期生成的各种字面量和符号引用
- **异常**：`OutOfMemoryError: Metaspace`

**6. 直接内存（Direct Memory）**

- **作用**：不是JVM运行时数据区的一部分，但也会导致OOM
- **特点**：NIO使用Native函数库直接分配堆外内存

#### 1.1.2 对象的内存布局

对象在堆内存中的存储布局可以分为三个部分：

1. **对象头（Header）**
   - Mark Word：存储对象的hashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID等
   - 类型指针：指向它的类型元数据的指针
   - 数组长度：如果是数组对象，还包含数组长度

2. **实例数据（Instance Data）**
   - 对象的有效信息，即程序代码中定义的各种类型的字段内容

3. **对齐填充（Padding）**
   - 占位符，确保对象大小是8字节的整数倍

#### 1.1.3 对象的访问定位

Java程序通过栈上的reference数据来操作堆上的具体对象。reference的访问方式主要有两种：

1. **句柄访问**
   - reference中存储的是对象句柄的地址
   - 句柄包含对象实例数据地址和对象类型数据地址

2. **直接指针访问**（HotSpot采用）
   - reference中直接存储对象地址
   - 访问速度更快

### 1.2 垃圾回收机制

#### 1.2.1 判断对象是否可回收

**1. 引用计数算法**

- **原理**：给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1；引用失效时，计数器就减1。
- **缺点**：无法解决循环引用的问题

**2. 可达性分析算法**（Java采用）

- **原理**：通过一系列称为"GC Roots"的根对象作为起始节点，从这些节点开始向下搜索，搜索过程所走过的路径称为"引用链"，如果某个对象到GC Roots间没有任何引用链相连，则证明此对象不可达。
- **GC Roots包括**：
  - 虚拟机栈中引用的对象
  - 方法区中类静态属性引用的对象
  - 方法区中常量引用的对象
  - 本地方法栈中Native方法引用的对象
  - 同步锁持有的对象

**3. 引用类型**

- **强引用（Strong Reference）**：最常见的引用，只要强引用存在，对象就不会被回收
- **软引用（Soft Reference）**：内存不足时会被回收
- **弱引用（Weak Reference）**：下一次GC时会被回收
- **虚引用（Phantom Reference）**：无法通过虚引用获取对象，唯一目的是对象被回收时收到一个系统通知

#### 1.2.2 垃圾回收算法

**1. 标记-清除算法（Mark-Sweep）**

- **过程**：
  1. 标记所有需要回收的对象
  2. 清除被标记的对象
- **优点**：实现简单
- **缺点**：
  - 效率不稳定（标记和清除两个过程的效率随对象数量增长而降低）
  - 内存空间碎片化

**2. 标记-复制算法（Copying）**

- **过程**：将可用内存按容量分为大小相等的两块，每次只使用其中一块。当这一块内存用完了，就将还存活的对象复制到另一块，然后把已使用过的内存空间一次清理掉。
- **优点**：
  - 实现简单，运行高效
  - 不会有内存碎片
- **缺点**：
  - 内存可用空间缩小为原来的一半
  - 如果存活对象较多，复制开销大
- **应用**：新生代的GC

**3. 标记-整理算法（Mark-Compact）**

- **过程**：
  1. 标记所有需要回收的对象
  2. 将存活对象向内存空间的一端移动
  3. 清理掉边界以外的内存
- **优点**：
  - 不会产生内存碎片
  - 适合老年代
- **缺点**：移动对象需要更新引用，效率略低

**4. 分代收集算法（Generational Collection）**

- **原理**：根据对象存活周期的不同将内存划分为几块，采用不同的收集算法。
- **新生代**：使用复制算法（存活对象少）
- **老年代**：使用标记-清除或标记-整理算法（存活对象多）

#### 1.2.3 垃圾收集器

**1. Serial收集器**

- **特点**：
  - 单线程收集器
  - 在GC时，必须暂停其他所有工作线程（Stop The World）
- **适用场景**：客户端应用、单核或小内存的服务器

**2. ParNew收集器**

- **特点**：
  - Serial收集器的多线程版本
  - 新生代收集器
- **适用场景**：Server模式下的首选新生代收集器

**3. Parallel Scavenge收集器**

- **特点**：
  - 新生代收集器
  - 关注吞吐量（吞吐量 = 运行用户代码时间 / (运行用户代码时间 + GC时间)）
  - 可以设置最大GC停顿时间和吞吐量目标

**4. Serial Old收集器**

- **特点**：Serial收集器的老年代版本

**5. Parallel Old收集器**

- **特点**：Parallel Scavenge收集器的老年代版本

**6. CMS收集器（Concurrent Mark Sweep）**

- **特点**：
  - 老年代收集器
  - 并发标记清除
  - 以获取最短回收停顿时间为目标
- **过程**：
  1. 初始标记（Stop The World）
  2. 并发标记
  3. 重新标记（Stop The World）
  4. 并发清除
- **缺点**：
  - 对CPU资源敏感
  - 无法处理浮动垃圾
  - 会产生内存碎片

**7. G1收集器（Garbage First）**

- **特点**：
  - 面向服务端的垃圾收集器
  - 可预测的停顿时间模型
  - 将Java堆划分为多个大小相等的独立区域（Region）
  - 可以独立进行垃圾回收
- **适用场景**：大内存（6GB以上）应用
- **过程**：
  1. 初始标记
  2. 并发标记
  3. 最终标记
  4. 筛选回收

**8. ZGC收集器**

- **特点**：
  - 低延迟垃圾收集器
  - 停顿时间不超过10ms
  - 适合大堆内存（8MB~16TB）

#### 1.2.4 对象分配规则

**1. 对象优先在Eden分配**

- 大多数情况下，对象在新生代Eden区分配
- 当Eden区没有足够空间时，触发Minor GC

**2. 大对象直接进入老年代**

- 大对象指需要大量连续内存空间的Java对象
- 通过`-XX:PretenureSizeThreshold`参数设置阈值

**3. 长期存活的对象进入老年代**

- 对象在Survivor区每经过一次Minor GC，年龄就增加1
- 当年龄达到一定程度（默认15）时，晋升到老年代
- 通过`-XX:MaxTenuringThreshold`参数设置

**4. 动态对象年龄判定**

- 如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半
- 年龄大于或等于该年龄的对象可以直接进入老年代

**5. 空间分配担保**

- 在发生Minor GC之前，检查老年代最大可用连续空间是否大于新生代所有对象总空间
- 如果大于，则Minor GC是安全的
- 如果小于，则查看`-XX:HandlePromotionFailure`参数是否允许担保失败

### 1.3 类加载机制

#### 1.3.1 类加载的时机

Java虚拟机规范并没有强制约束类加载的时机，但严格规定了有且只有以下6种情况必须立即对类进行初始化：

1. 遇到`new`、`getstatic`、`putstatic`、`invokestatic`这4条字节码指令时
2. 使用`java.lang.reflect`包的方法对类进行反射调用时
3. 当初始化一个类时，如果父类还没有初始化，需要先触发父类初始化
4. 虚拟机启动时，用户指定的主类（包含main方法的类）需要初始化
5. 当使用JDK 7+的动态语言支持时，如果一个`java.lang.invoke.MethodHandle`实例的解析结果为`REF_getStatic`、`REF_putStatic`、`REF_invokeStatic`的方法句柄，并且这个方法句柄对应的类没有初始化
6. 当一个接口定义了默认方法（JDK 8+），如果该接口的实现类初始化，则接口需要初始化

#### 1.3.2 类加载的过程

类加载的过程包括：**加载（Loading）**、**验证（Verification）**、**准备（Preparation）**、**解析（Resolution）**、**初始化（Initialization）**。

**1. 加载（Loading）**

- 通过类的全限定名获取类的二进制字节流
- 将字节流所代表的静态存储结构转换为方法区的运行时数据结构
- 在内存中生成一个代表这个类的`java.lang.Class`对象，作为方法区这个类的各种数据的访问入口

**2. 验证（Verification）**

- **文件格式验证**：验证字节流是否符合Class文件格式规范
- **元数据验证**：对类的元数据进行语义校验
- **字节码验证**：通过数据流分析和控制流分析，确定程序语义是合法的
- **符号引用验证**：在解析阶段验证符号引用是否可以解析

**3. 准备（Preparation）**

- 为类变量（静态变量）分配内存并设置初始值（零值）
- **注意**：这里设置的是零值，不是代码中赋予的初始值
  ```java
  public static int value = 123;  // 准备阶段value=0，初始化阶段value=123
  ```

**4. 解析（Resolution）**

- 将常量池内的符号引用替换为直接引用
- 符号引用：一组符号来描述所引用的目标
- 直接引用：直接指向目标的指针、相对偏移量或能间接定位到目标的句柄

**5. 初始化（Initialization）**

- 执行类构造器`<clinit>()`方法
- `<clinit>()`方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的
- 编译器收集的顺序是由语句在源文件中出现的顺序决定的

#### 1.3.3 类加载器

**1. 类加载器的层次结构**

- **启动类加载器（Bootstrap ClassLoader）**
  - 由C++实现，是虚拟机自身的一部分
  - 负责加载`<JAVA_HOME>/lib`目录下的核心类库
  - 无法被Java程序直接引用

- **扩展类加载器（Extension ClassLoader）**
  - 由Java实现，继承自`java.lang.ClassLoader`
  - 负责加载`<JAVA_HOME>/lib/ext`目录下的类库

- **应用程序类加载器（Application ClassLoader）**
  - 也称为系统类加载器（System ClassLoader）
  - 负责加载用户类路径（ClassPath）上的类库
  - 是最常用的类加载器

**2. 双亲委派模型（Parents Delegation Model）**

- **工作原理**：
  1. 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类
  2. 而是把这个请求委派给父类加载器去完成
  3. 只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载

- **优点**：
  - 保证Java核心库的类型安全
  - 避免类的重复加载

**3. 自定义类加载器**

```java
public class MyClassLoader extends ClassLoader {
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        // 1. 读取.class文件
        byte[] bytes = loadClassData(name);
        // 2. 调用defineClass定义类
        return defineClass(name, bytes, 0, bytes.length);
    }
    
    private byte[] loadClassData(String name) {
        // 读取文件并返回字节数组
        return null;
    }
}
```

### 1.4 JVM调优

#### 1.4.1 常用JVM参数

**堆内存相关：**
- `-Xms`：初始堆内存大小
- `-Xmx`：最大堆内存大小
- `-Xmn`：新生代大小
- `-XX:NewRatio`：老年代与新生代的比例
- `-XX:SurvivorRatio`：Eden区与Survivor区的比例

**GC相关：**
- `-XX:+UseSerialGC`：使用Serial收集器
- `-XX:+UseParallelGC`：使用Parallel收集器
- `-XX:+UseConcMarkSweepGC`：使用CMS收集器
- `-XX:+UseG1GC`：使用G1收集器
- `-XX:MaxGCPauseMillis`：最大GC停顿时间
- `-XX:GCTimeRatio`：GC时间占比

**方法区/元空间相关：**
- `-XX:PermSize`：永久代初始大小（Java 8之前）
- `-XX:MaxPermSize`：永久代最大大小（Java 8之前）
- `-XX:MetaspaceSize`：元空间初始大小（Java 8+）
- `-XX:MaxMetaspaceSize`：元空间最大大小（Java 8+）

**其他：**
- `-XX:+PrintGCDetails`：打印GC详细信息
- `-XX:+HeapDumpOnOutOfMemoryError`：OOM时生成堆转储文件
- `-Xss`：线程栈大小

#### 1.4.2 JVM调优工具

**1. jps（JVM Process Status Tool）**
- 列出正在运行的虚拟机进程

**2. jstat（JVM Statistics Monitoring Tool）**
- 监控虚拟机各种运行状态信息

**3. jmap（Memory Map）**
- 生成堆转储快照（heap dump）
- 查看堆内存详情

**4. jstack（Stack Trace）**
- 生成虚拟机当前时刻的线程快照
- 用于定位线程死锁、长时间停顿等问题

**5. jvisualvm（VisualVM）**
- 可视化工具，整合了以上工具的功能

**6. jconsole（Java Monitoring and Management Console）**
- 图形化监控工具

---

## 2. 并发编程深入

### 2.1 volatile关键字

#### 2.1.1 volatile的特性

**1. 可见性（Visibility）**

- 当一个线程修改了volatile变量的值，新值对其他线程立即可见
- 保证变量值直接从主内存读取，修改后立即写入主内存

**2. 有序性（Ordering）**

- 禁止指令重排序优化
- 保证volatile变量之前的操作不会被重排序到volatile操作之后
- 保证volatile变量之后的操作不会被重排序到volatile操作之前

**注意：volatile不保证原子性！**

例如：`count++`不是原子操作，volatile不能保证线程安全。

#### 2.1.2 volatile的实现原理

- 使用volatile修饰的变量，在编译后会多出一个`lock`前缀指令
- `lock`前缀指令会：
  1. 将当前处理器缓存行的数据写回到系统内存
  2. 这个写回操作会使其他CPU里缓存了该内存地址的数据无效

### 2.2 synchronized关键字

#### 2.2.1 synchronized的用法

```java
// 1. 同步方法
public synchronized void method() {
    // 临界区代码
}

// 2. 同步代码块
synchronized (obj) {
    // 临界区代码
}

// 3. 静态同步方法
public static synchronized void staticMethod() {
    // 临界区代码
}
```

#### 2.2.2 synchronized的底层原理

**1. 对象头（Object Header）**

- Mark Word：存储对象的hashCode、GC分代年龄、锁状态标志等
- 不同的锁状态，Mark Word的结构不同

**2. 锁的升级过程**

- **无锁状态**：对象刚创建时的状态

- **偏向锁（Biased Locking）**
  - 大多数情况下，锁总是由同一线程多次获得
  - 偏向锁会记录获取锁的线程ID
  - 当同一线程再次请求锁时，无需同步操作

- **轻量级锁（Lightweight Locking）**
  - 当有多个线程竞争时，升级为轻量级锁
  - 使用CAS操作尝试获取锁
  - 如果失败，则升级为重量级锁

- **重量级锁（Heavyweight Locking）**
  - 轻量级锁竞争失败后，升级为重量级锁
  - 使用操作系统级别的互斥锁（Mutex Lock）
  - 线程阻塞，进入等待队列

**3. 字节码层面**

- `monitorenter`：进入同步块
- `monitorexit`：退出同步块

### 2.3 CAS（Compare-And-Swap）

#### 2.3.1 CAS的工作原理

CAS操作包含三个操作数：
- 内存位置（V）
- 预期原值（A）
- 新值（B）

如果V的值等于A，则将V的值更新为B，否则不做任何操作。

这是一个原子操作，由CPU指令保证。

#### 2.3.2 CAS的优缺点

**优点：**
- 无锁编程，性能较高
- 避免了线程切换的开销

**缺点：**
- **ABA问题**：虽然值没有变化，但可能中间被修改过
  - 解决方案：使用版本号（AtomicStampedReference）
- **循环时间长开销大**：CAS操作失败会一直循环
- **只能保证一个共享变量的原子操作**

### 2.4 AQS（AbstractQueuedSynchronizer）

#### 2.4.1 AQS的核心概念

**1. 核心数据结构**

- **state**：同步状态，使用volatile修饰，保证可见性
- **CLH队列**：等待队列，双向链表实现
- **Node**：队列节点，包含线程引用、等待状态等

**2. 核心方法**

- `tryAcquire(int)`：尝试获取独占锁
- `tryRelease(int)`：尝试释放独占锁
- `tryAcquireShared(int)`：尝试获取共享锁
- `tryReleaseShared(int)`：尝试释放共享锁
- `acquire(int)`：获取锁（会调用tryAcquire）
- `release(int)`：释放锁（会调用tryRelease）

#### 2.4.2 基于AQS的实现

- `ReentrantLock`：可重入锁
- `CountDownLatch`：倒计时门闩
- `Semaphore`：信号量
- `ReentrantReadWriteLock`：读写锁

### 2.5 线程池

#### 2.5.1 线程池的核心参数

1. **corePoolSize**：核心线程数，线程池中保持的线程数量（即使空闲）
2. **maximumPoolSize**：最大线程数，线程池允许的最大线程数
3. **keepAliveTime**：线程空闲时间，非核心线程的空闲时间超过该值会被回收
4. **unit**：时间单位
5. **workQueue**：任务队列，用于保存等待执行的任务
6. **threadFactory**：线程工厂，用于创建新线程
7. **handler**：拒绝策略

#### 2.5.2 线程池的工作流程

1. 提交任务
2. 如果当前线程数 < corePoolSize，创建新线程执行
3. 如果当前线程数 >= corePoolSize，将任务放入队列
4. 如果队列满了且线程数 < maximumPoolSize，创建新线程执行
5. 如果队列满了且线程数 >= maximumPoolSize，执行拒绝策略

#### 2.5.3 拒绝策略

- **AbortPolicy**：直接抛出异常（默认）
- **CallerRunsPolicy**：调用者线程执行
- **DiscardPolicy**：直接丢弃任务
- **DiscardOldestPolicy**：丢弃最老的任务

### 2.6 并发集合

#### 2.6.1 ConcurrentHashMap

- **线程安全的HashMap**
- **Java 7**：分段锁机制（Segment）
- **Java 8**：CAS + synchronized

#### 2.6.2 CopyOnWriteArrayList

- **写时复制的ArrayList**
- **适用场景**：读多写少
- 写入操作会复制整个数组，开销较大

#### 2.6.3 BlockingQueue

- **阻塞队列接口**
- **实现类**：
  - `ArrayBlockingQueue`：有界阻塞队列（数组实现）
  - `LinkedBlockingQueue`：可选有界阻塞队列（链表实现）
  - `SynchronousQueue`：同步队列，不存储元素
  - `PriorityBlockingQueue`：优先级阻塞队列

### 2.7 Fork/Join框架

#### 2.7.1 Fork/Join的原理

- **分而治之（Divide and Conquer）**
- 将大任务分割成小任务，并行执行，最后合并结果

#### 2.7.2 核心类

- **ForkJoinPool**：线程池
- **ForkJoinTask**：任务基类
  - `RecursiveTask`：有返回值的任务
  - `RecursiveAction`：无返回值的任务

### 2.8 ThreadLocal

#### 2.8.1 ThreadLocal的原理

- 为每个线程提供独立的变量副本
- 实现原理：Thread类中有一个`ThreadLocalMap`变量
- `ThreadLocalMap`的key是ThreadLocal对象，value是存储的值

#### 2.8.2 内存泄漏问题

- ThreadLocal使用不当可能导致内存泄漏
- 使用完后要调用`remove()`方法

---

## 3. 设计模式

### 3.1 设计模式概述

设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。

**设计模式的分类：**
- **创建型模式**：关注对象的创建
- **结构型模式**：关注类和对象的组合
- **行为型模式**：关注对象之间的通信

### 3.2 创建型模式

#### 3.2.1 单例模式（Singleton Pattern）

**意图**：确保一个类只有一个实例，并提供一个全局访问点。

**实现方式：**

1. **饿汉式**
```java
class Singleton {
    private static final Singleton instance = new Singleton();
    private Singleton() {}
    public static Singleton getInstance() {
        return instance;
    }
}
```

2. **懒汉式（双重检查锁定）**
```java
class Singleton {
    private volatile static Singleton instance;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

3. **静态内部类（推荐）**
```java
class Singleton {
    private Singleton() {}
    private static class SingletonHolder {
        private static final Singleton instance = new Singleton();
    }
    public static Singleton getInstance() {
        return SingletonHolder.instance;
    }
}
```

4. **枚举（推荐，线程安全且防止反序列化）**
```java
enum Singleton {
    INSTANCE;
    public void doSomething() {}
}
```

#### 3.2.2 工厂模式（Factory Pattern）

**意图**：定义一个创建对象的接口，让子类决定实例化哪一个类。

**1. 简单工厂模式**
```java
class SimpleFactory {
    public static Product createProduct(String type) {
        if ("A".equals(type)) {
            return new ProductA();
        } else if ("B".equals(type)) {
            return new ProductB();
        }
        return null;
    }
}
```

**2. 工厂方法模式**
```java
interface Factory {
    Product createProduct();
}

class FactoryA implements Factory {
    @Override
    public Product createProduct() {
        return new ProductA();
    }
}
```

**3. 抽象工厂模式**
```java
interface AbstractFactory {
    ProductA createProductA();
    ProductB createProductB();
}
```

#### 3.2.3 建造者模式（Builder Pattern）

**意图**：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

```java
class Product {
    private String partA;
    private String partB;
    // getter和setter
}

class Builder {
    private Product product = new Product();
    
    public Builder setPartA(String partA) {
        product.setPartA(partA);
        return this;
    }
    
    public Product build() {
        return product;
    }
}
```

### 3.3 结构型模式

#### 3.3.1 代理模式（Proxy Pattern）

**意图**：为其他对象提供一种代理以控制对这个对象的访问。

**1. 静态代理**
```java
interface Subject {
    void request();
}

class RealSubject implements Subject {
    @Override
    public void request() {
        System.out.println("真实请求");
    }
}

class Proxy implements Subject {
    private RealSubject realSubject;
    
    @Override
    public void request() {
        preRequest();
        realSubject.request();
        postRequest();
    }
}
```

**2. 动态代理**
```java
class DynamicProxy implements InvocationHandler {
    private Object target;
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) {
        return method.invoke(target, args);
    }
}
```

#### 3.3.2 适配器模式（Adapter Pattern）

**意图**：将一个类的接口转换成客户希望的另一个接口。

```java
interface Target {
    void request();
}

class Adaptee {
    public void specificRequest() {}
}

class Adapter implements Target {
    private Adaptee adaptee;
    
    @Override
    public void request() {
        adaptee.specificRequest();
    }
}
```

#### 3.3.3 装饰器模式（Decorator Pattern）

**意图**：动态地给一个对象添加一些额外的职责。

```java
interface Component {
    void operation();
}

class ConcreteComponent implements Component {
    @Override
    public void operation() {}
}

abstract class Decorator implements Component {
    protected Component component;
    
    @Override
    public void operation() {
        component.operation();
    }
}
```

### 3.4 行为型模式

#### 3.4.1 观察者模式（Observer Pattern）

**意图**：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

```java
interface Observer {
    void update(String message);
}

interface Subject {
    void attach(Observer observer);
    void notifyObservers(String message);
}

class ConcreteSubject implements Subject {
    private List<Observer> observers = new ArrayList<>();
    
    @Override
    public void attach(Observer observer) {
        observers.add(observer);
    }
    
    @Override
    public void notifyObservers(String message) {
        for (Observer observer : observers) {
            observer.update(message);
        }
    }
}
```

#### 3.4.2 策略模式（Strategy Pattern）

**意图**：定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。

```java
interface Strategy {
    int execute(int a, int b);
}

class AddStrategy implements Strategy {
    @Override
    public int execute(int a, int b) {
        return a + b;
    }
}

class Context {
    private Strategy strategy;
    
    public void setStrategy(Strategy strategy) {
        this.strategy = strategy;
    }
    
    public int executeStrategy(int a, int b) {
        return strategy.execute(a, b);
    }
}
```

#### 3.4.3 责任链模式（Chain of Responsibility Pattern）

**意图**：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。

```java
abstract class Handler {
    protected Handler nextHandler;
    
    public void setNext(Handler handler) {
        this.nextHandler = handler;
    }
    
    public abstract void handleRequest(Request request);
}
```

#### 3.4.4 模板方法模式（Template Method Pattern）

**意图**：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。

```java
abstract class AbstractClass {
    public final void templateMethod() {
        step1();
        step2();
        step3();
    }
    
    protected abstract void step1();
    protected abstract void step2();
    
    protected void step3() {
        // 默认实现
    }
}
```

---

## 总结

本文档涵盖了Java进阶阶段的所有重要知识点。学习建议：

1. **深入理解原理**：不仅要会用，更要理解为什么
2. **阅读源码**：JDK源码是最好的学习材料
3. **实践应用**：在实际项目中应用所学知识
4. **持续学习**：关注新技术和发展趋势

**祝学习顺利，成为Java高级工程师！**

