# 数据结构与算法理论知识

本文档涵盖数据结构和算法的所有重要理论知识，是学习数据结构和算法的理论基础。

---

## 目录

1. [数据结构基础](#1-数据结构基础)
2. [线性结构](#2-线性结构)
3. [树结构](#3-树结构)
4. [图结构](#4-图结构)
5. [排序算法](#5-排序算法)
6. [查找算法](#6-查找算法)
7. [动态规划](#7-动态规划)
8. [贪心算法](#8-贪心算法)
9. [回溯算法](#9-回溯算法)
10. [复杂度分析](#10-复杂度分析)

---

## 理论与代码对应关系

- **线性结构**：
  - `data-structure-algorithm-practice/src/main/java/com/struct/practice/LinearStructurePractice.java`
  - `array-demo`、`linkedList-demo`、`stack`、`queue-demo`
- **树与堆**：
  - `data-structure-algorithm-practice/src/main/java/com/struct/practice/TreeStructurePractice.java`
  - `tree`、`heap`（例如：`heap/src/main/java/com/struct/HeapSort.java`）
- **排序算法**：
  - `data-structure-algorithm-practice/src/main/java/com/struct/practice/SortingAlgorithmPractice.java`
  - `sorts`
- **查找算法**：
  - `data-structure-algorithm-practice/src/main/java/com/struct/practice/SearchAlgorithmPractice.java`
  - `serach`
- **图算法**：
  - `data-structure-algorithm-practice/src/main/java/com/struct/practice/GraphAlgorithmPractice.java`
- **动态规划**：
  - `data-structure-algorithm-practice/src/main/java/com/struct/practice/DynamicProgrammingPractice.java`

---

## 1. 数据结构基础

### 1.1 数据结构的概念

**数据结构**是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。

### 1.2 数据结构的分类

**1. 线性结构**
- 数组、链表、栈、队列
- 数据元素之间存在一对一的关系

**2. 树形结构**
- 二叉树、二叉搜索树、堆、哈夫曼树
- 数据元素之间存在一对多的关系

**3. 图形结构**
- 有向图、无向图
- 数据元素之间存在多对多的关系

**4. 集合结构**
- 数据元素之间除了"同属于一个集合"的关系外，没有其他关系

### 1.3 抽象数据类型（ADT）

抽象数据类型是指一个数学模型以及定义在该模型上的一组操作。

**ADT的三个组成部分：**
1. 数据对象
2. 数据关系
3. 基本操作

---

## 2. 线性结构

### 2.1 数组（Array）

**定义**：数组是一种线性数据结构，用一组连续的内存空间存储相同类型的数据。

**特点：**
- 随机访问：通过索引可以在O(1)时间内访问任意元素
- 插入和删除：需要移动元素，时间复杂度O(n)
- 内存连续：需要预先分配固定大小的内存空间

**操作复杂度：**
- 查找：O(1)（通过索引）
- 插入：O(n)
- 删除：O(n)

**动态数组：**
- 当数组容量不足时，需要扩容（通常扩容为原来的2倍）
- 扩容时需要复制所有元素到新数组，时间复杂度O(n)

### 2.2 链表（Linked List）

**定义**：链表是一种线性数据结构，通过指针将零散的内存块串联起来。

**单链表：**
- 每个节点包含数据和指向下一个节点的指针
- 头节点指向第一个元素
- 最后一个节点的指针指向null

**双链表：**
- 每个节点包含数据、指向前一个节点的指针和指向下一个节点的指针
- 可以从前往后或从后往前遍历

**循环链表：**
- 最后一个节点的指针指向头节点
- 可以从任意节点开始遍历

**特点：**
- 不需要连续的内存空间
- 插入和删除操作的时间复杂度为O(1)（已知位置）
- 查找需要遍历，时间复杂度O(n)

**操作复杂度：**
- 查找：O(n)
- 插入：O(1)（已知位置）
- 删除：O(1)（已知位置）

### 2.3 栈（Stack）

**定义**：栈是一种后进先出（LIFO, Last In First Out）的线性数据结构。

**基本操作：**
- `push()`：入栈，将元素压入栈顶
- `pop()`：出栈，弹出栈顶元素
- `peek()`：查看栈顶元素，不删除
- `isEmpty()`：判断栈是否为空

**实现方式：**
- 数组实现：使用数组和栈顶指针
- 链表实现：使用链表，在头部进行插入和删除

**应用场景：**
- 函数调用栈
- 表达式求值
- 括号匹配
- 浏览器前进后退

**操作复杂度：**
- 入队/出队/查看队首：通常为O(1)
- 注意：如果底层实现需要扩容（例如动态数组），会出现摊还成本（amortized）

### 2.4 队列（Queue）

**定义**：队列是一种先进先出（FIFO, First In First Out）的线性数据结构。

**基本操作：**
- `enqueue()`：入队，将元素添加到队尾
- `dequeue()`：出队，从队首移除元素
- `peek()`：查看队首元素
- `isEmpty()`：判断队列是否为空

**实现方式：**
- 数组实现：使用循环数组避免数据搬移
- 链表实现：使用链表，在头部删除，尾部插入

**双端队列（Deque）：**
- 可以在两端进行插入和删除操作

**优先队列（Priority Queue）：**
- 元素按优先级出队
- 通常使用堆实现

**应用场景：**
- 任务调度
- 消息队列
- 广度优先搜索

**操作复杂度：**
- 所有操作：O(1)

---

## 3. 树结构

### 3.1 树的基本概念

**树的定义**：树是n（n≥0）个节点的有限集合。当n=0时，称为空树。

**基本术语：**
- **节点**：树中的每个元素
- **根节点**：没有父节点的节点
- **叶子节点**：没有子节点的节点
- **度**：节点拥有的子树个数
- **深度**：从根节点到该节点的路径长度
- **高度**：从该节点到最深叶子节点的路径长度

### 3.2 二叉树（Binary Tree）

**定义**：每个节点最多有两个子节点的树结构。

**性质：**
- 第i层最多有2^(i-1)个节点
- 深度为k的二叉树最多有2^k - 1个节点
- 具有n个节点的完全二叉树的深度为⌊log₂n⌋ + 1

**特殊二叉树：**
- **满二叉树**：所有非叶子节点都有两个子节点
- **完全二叉树**：除了最后一层，其他层都是满的，最后一层从左到右填充

**遍历方式：**
- **前序遍历**：根 → 左 → 右
- **中序遍历**：左 → 根 → 右
- **后序遍历**：左 → 右 → 根
- **层序遍历**：从上到下，从左到右

### 3.3 二叉搜索树（BST）

**定义**：对于树中的任意节点，其左子树中所有节点的值都小于该节点的值，右子树中所有节点的值都大于该节点的值。

**性质：**
- 中序遍历BST得到有序序列
- 查找、插入、删除的平均时间复杂度为O(logn)
- 最坏情况下（退化为链表）时间复杂度为O(n)

**操作：**
- **查找**：从根节点开始，比较目标值与当前节点值
- **插入**：找到合适的插入位置
- **删除**：
  - 叶子节点：直接删除
  - 只有一个子节点：用子节点替换
  - 有两个子节点：用右子树的最小值替换

### 3.4 平衡二叉树

**AVL树：**
- 任意节点的左右子树高度差不超过1
- 通过旋转操作保持平衡
- 查找、插入、删除的时间复杂度为O(logn)

**红黑树：**
- 一种自平衡二叉搜索树
- 通过颜色标记和旋转操作保持平衡
- Java的TreeMap和TreeSet使用红黑树实现

### 3.5 堆（Heap）

**定义**：堆是一种完全二叉树，满足堆序性质。

**最大堆：**
- 父节点的值大于或等于子节点的值
- 根节点是最大值

**最小堆：**
- 父节点的值小于或等于子节点的值
- 根节点是最小值

**操作：**
- **插入**：将元素添加到末尾，然后向上调整（heapify up）
- **删除**：将根节点与最后一个节点交换，删除最后一个节点，然后向下调整（heapify down）

**应用：**
- 优先队列
- 堆排序
- Top K问题

**操作复杂度：**
- 插入：O(logn)
- 删除：O(logn)
- 查找最大值/最小值：O(1)

---

## 4. 图结构

### 4.1 图的基本概念

**图的定义**：图是由顶点（Vertex）和边（Edge）组成的数据结构。

**基本术语：**
- **顶点（Vertex）**：图中的节点
- **边（Edge）**：连接两个顶点的线
- **有向图**：边有方向
- **无向图**：边没有方向
- **度**：与顶点相连的边的数量
- **路径**：从顶点A到顶点B的顶点序列
- **环**：起点和终点相同的路径

### 4.2 图的表示

**1. 邻接矩阵**
- 使用二维数组表示
- `matrix[i][j]`表示顶点i到顶点j是否有边（或边的权重）
- 空间复杂度：O(V²)
- 适合稠密图

**2. 邻接表**
- 使用数组+链表表示
- 每个顶点维护一个链表，存储其邻居
- 空间复杂度：O(V + E)
- 适合稀疏图

### 4.3 图的遍历

**深度优先搜索（DFS）**
- 从起始顶点开始，尽可能深地搜索
- 使用栈（递归）实现
- 时间复杂度：O(V + E)

**广度优先搜索（BFS）**
- 从起始顶点开始，逐层搜索
- 使用队列实现
- 时间复杂度：O(V + E)
- 可以找到最短路径（无权图）

### 4.4 最短路径算法

**Dijkstra算法**
- 单源最短路径算法
- 适用于非负权重的有向图
- 使用优先队列（最小堆）
- 时间复杂度：O((V + E)logV)

**Floyd算法**
- 所有节点对之间的最短路径
- 使用动态规划
- 时间复杂度：O(V³)
- 空间复杂度：O(V²)

### 4.5 最小生成树（MST）

**定义**：连接所有顶点的边权值之和最小的树。

**Prim算法**
- 从任意顶点开始，逐步扩展
- 每次选择连接已选顶点和未选顶点的最小权重边
- 时间复杂度：O(V²)或O(ElogV)（使用优先队列）

**Kruskal算法**
- 按边权重从小到大排序
- 使用并查集判断是否形成环
- 时间复杂度：O(ElogE)

### 4.6 拓扑排序

**定义**：对有向无环图（DAG）的顶点进行排序，使得对于每条边(u, v)，u在排序中出现在v之前。

**算法：**
1. 计算每个顶点的入度
2. 将所有入度为0的顶点入队
3. 出队一个顶点，将其所有邻居的入度减1
4. 如果邻居的入度变为0，入队
5. 重复步骤3-4，直到队列为空

---

## 5. 排序算法

### 5.1 排序算法分类

**按稳定性分类：**
- **稳定排序**：相等元素的相对顺序不变（冒泡、插入、归并、计数、桶、基数）
- **不稳定排序**：相等元素的相对顺序可能改变（选择、快速、堆、希尔）

**按时间复杂度分类：**
- **O(n²)**：冒泡、选择、插入
- **O(nlogn)**：快速、归并、堆、希尔
- **O(n)**：计数、桶、基数（特殊条件）

### 5.2 基础排序算法

**冒泡排序（Bubble Sort）**
- 比较相邻元素，如果顺序错误则交换
- 每轮将最大元素"冒泡"到末尾
- 时间复杂度：O(n²)
- 空间复杂度：O(1)
- 稳定性：稳定

**选择排序（Selection Sort）**
- 每次找到未排序部分的最小值，放到已排序部分的末尾
- 时间复杂度：O(n²)
- 空间复杂度：O(1)
- 稳定性：不稳定

**插入排序（Insertion Sort）**
- 将元素插入到已排序部分的正确位置
- 适合小规模数据或基本有序的数据
- 时间复杂度：O(n²)
- 空间复杂度：O(1)
- 稳定性：稳定

### 5.3 高级排序算法

**快速排序（Quick Sort）**
- 选择基准元素，将数组分为两部分
- 递归排序两部分
- 平均时间复杂度：O(nlogn)
- 最坏时间复杂度：O(n²)（已排序数组）
- 空间复杂度：O(logn)
- 稳定性：不稳定

**归并排序（Merge Sort）**
- 将数组分成两半，递归排序，然后合并
- 时间复杂度：O(nlogn)
- 空间复杂度：O(n)
- 稳定性：稳定

**堆排序（Heap Sort）**
- 构建最大堆，依次取出堆顶元素
- 时间复杂度：O(nlogn)
- 空间复杂度：O(1)
- 稳定性：不稳定

**希尔排序（Shell Sort）**
- 插入排序的改进，使用增量序列
- 时间复杂度：与增量序列有关，最坏可达O(n²)
- 空间复杂度：O(1)
- 稳定性：不稳定

### 5.4 特殊排序算法

**计数排序（Counting Sort）**
- 统计每个元素出现的次数
- 适用于数据范围较小的整数
- 时间复杂度：O(n + k)，k是数据范围
- 空间复杂度：O(k)
- 稳定性：稳定

**桶排序（Bucket Sort）**
- 将数据分配到多个桶中，对每个桶排序
- 适用于数据分布均匀的情况
- 时间复杂度：平均O(n + k)，最坏O(n²)
- 空间复杂度：O(n + k)
- 稳定性：稳定

**基数排序（Radix Sort）**
- 按位进行排序（个位、十位、百位...）
- 适用于非负整数
- 时间复杂度：O(d * (n + k))，d是位数
- 空间复杂度：O(n + k)
- 稳定性：稳定

---

## 6. 查找算法

### 6.1 顺序查找

**定义**：从第一个元素开始，逐个比较，直到找到目标或遍历完整个数组。

**时间复杂度：** O(n)
**空间复杂度：** O(1)

### 6.2 二分查找

**前提条件：** 数组必须有序

**算法步骤：**
1. 确定查找范围的左右边界
2. 计算中点
3. 比较中点值与目标值
4. 根据比较结果缩小查找范围
5. 重复步骤2-4，直到找到或范围为空

**时间复杂度：** O(logn)
**空间复杂度：** O(1)（迭代）或O(logn)（递归）

**变体：**
- 查找第一个等于target的元素
- 查找最后一个等于target的元素
- 查找第一个大于等于target的元素

### 6.3 其他查找算法

**插值查找**
- 二分查找的改进，使用插值公式计算中点
- 适用于数据分布均匀的有序数组
- 平均时间复杂度：O(loglogn)
- 最坏时间复杂度：O(n)

**斐波那契查找**
- 使用黄金分割点进行查找
- 时间复杂度：O(logn)

**哈希查找**
- 使用哈希表进行查找
- 平均时间复杂度：O(1)
- 最坏时间复杂度：O(n)

---

## 7. 动态规划

### 7.1 动态规划的概念

**定义**：动态规划（Dynamic Programming）是一种通过把原问题分解为相对简单的子问题的方式来解决复杂问题的方法。

**核心思想：**
- 将问题分解为子问题
- 保存子问题的解，避免重复计算
- 自底向上或自顶向下求解

### 7.2 动态规划的特征

**1. 最优子结构**
- 问题的最优解包含子问题的最优解

**2. 重叠子问题**
- 递归过程中会重复计算相同的子问题

**3. 无后效性**
- 当前状态只依赖于之前的状态，不依赖于未来的状态

### 7.3 动态规划的步骤

1. **定义状态**：dp[i]或dp[i][j]表示什么
2. **状态转移方程**：如何从子问题的解得到当前问题的解
3. **初始状态**：边界条件
4. **计算顺序**：确定计算顺序，保证计算当前状态时，所需的状态已经计算过

### 7.4 经典问题

**斐波那契数列**
- 状态：dp[i]表示第i个斐波那契数
- 转移：dp[i] = dp[i-1] + dp[i-2]
- 初始：dp[0] = 0, dp[1] = 1

**最长公共子序列（LCS）**
- 状态：dp[i][j]表示text1[0..i]和text2[0..j]的LCS长度
- 转移：
  - 如果text1[i] == text2[j]：dp[i][j] = dp[i-1][j-1] + 1
  - 否则：dp[i][j] = max(dp[i-1][j], dp[i][j-1])

**0-1背包问题**
- 状态：dp[i][w]表示前i个物品在容量w下的最大价值
- 转移：dp[i][w] = max(dp[i-1][w], dp[i-1][w-weights[i]] + values[i])

**最长递增子序列（LIS）**
- 状态：dp[i]表示以nums[i]结尾的最长递增子序列长度
- 转移：dp[i] = max(dp[j]) + 1，其中j < i且nums[j] < nums[i]

---

## 8. 贪心算法

### 8.1 贪心算法的概念

**定义**：贪心算法是一种在每一步选择中都采取在当前状态下最好或最优的选择，从而希望导致结果是全局最好或最优的算法。

**特点：**
- 局部最优选择
- 不能保证全局最优
- 适用于具有贪心选择性质的问题

### 8.2 贪心算法的适用条件

**1. 贪心选择性质**
- 可以通过局部最优选择达到全局最优

**2. 最优子结构**
- 问题的最优解包含子问题的最优解

### 8.3 经典问题

**活动选择问题**
- 选择最多的不重叠活动
- 贪心策略：每次选择结束时间最早的活动

**最小生成树**
- Prim和Kruskal算法都使用了贪心思想

**哈夫曼编码**
- 构建最优前缀编码
- 贪心策略：每次合并频率最小的两个节点

**找零问题**
- 用最少的硬币找零
- 贪心策略：每次选择面额最大的硬币（需要满足特定条件）

---

## 9. 回溯算法

### 9.1 回溯算法的概念

**定义**：回溯算法是一种通过探索所有可能的候选解来找出所有解的算法。如果候选解被确认不是一个解（或者至少不是最后一个解），回溯算法会通过在上一步进行一些变化来丢弃该解。

**特点：**
- 系统性搜索
- 深度优先搜索
- 可以找到所有解

### 9.2 回溯算法的框架

```java
void backtrack(路径, 选择列表) {
    if (满足结束条件) {
        将路径加入结果集;
        return;
    }
    
    for (选择 in 选择列表) {
        做选择;
        backtrack(路径, 选择列表);
        撤销选择;
    }
}
```

### 9.3 经典问题

**N皇后问题**
- 在N×N棋盘上放置N个皇后，使得它们不能相互攻击
- 回溯策略：逐行放置皇后，检查是否与已放置的皇后冲突
- 剪枝：如果当前位置不合法，直接回溯，不继续搜索
- 时间复杂度：O(N!)

**全排列问题**
- 生成数组的所有排列
- 回溯策略：依次选择每个位置可以放置的元素
- 使用visited数组标记已使用的元素
- 时间复杂度：O(n!)

**组合问题**
- 从n个元素中选择k个元素的所有组合
- 回溯策略：从当前位置开始选择，避免重复
- 剪枝：如果剩余元素不足以组成k个组合，提前返回
- 时间复杂度：O(C(n,k))

**子集问题**
- 生成数组的所有子集
- 回溯策略：对每个元素，选择包含或不包含
- 时间复杂度：O(2^n)

**数独问题**
- 填充9×9数独，使得每行、每列、每个3×3宫格都包含1-9
- 回溯策略：逐个填充空格，检查是否合法
- 剪枝：如果当前数字不合法，直接尝试下一个数字

**单词搜索**
- 在二维网格中搜索单词
- 回溯策略：从每个位置开始DFS搜索
- 使用visited数组避免重复访问同一位置

### 9.4 回溯算法的优化技巧

**剪枝（Pruning）**
- 提前判断当前路径不可能得到解，直接回溯
- 减少搜索空间，提高效率

**记忆化（Memoization）**
- 记录已计算过的状态，避免重复计算
- 适用于有重叠子问题的回溯问题

**约束传播（Constraint Propagation）**
- 在搜索过程中传播约束，减少选择空间
- 常用于约束满足问题（CSP）

---

## 10. 复杂度分析

### 10.1 时间复杂度

**定义**：算法执行时间随输入规模增长的趋势。

**大O表示法（Big-O Notation）**
- 描述算法的最坏情况时间复杂度
- 忽略常数因子和低阶项
- 关注增长趋势

**常见时间复杂度：**

| 复杂度 | 名称 | 示例 |
|--------|------|------|
| O(1) | 常数时间 | 数组随机访问 |
| O(logn) | 对数时间 | 二分查找 |
| O(n) | 线性时间 | 遍历数组 |
| O(nlogn) | 线性对数时间 | 快速排序、归并排序 |
| O(n²) | 平方时间 | 冒泡排序、选择排序 |
| O(n³) | 立方时间 | 三重循环 |
| O(2^n) | 指数时间 | 递归斐波那契 |
| O(n!) | 阶乘时间 | 全排列 |

**时间复杂度分析规则：**
1. 只关注最高阶项
2. 忽略常数因子
3. 考虑最坏情况
4. 平均情况分析

### 10.2 空间复杂度

**定义**：算法执行过程中所需的内存空间随输入规模增长的趋势。

**空间复杂度分类：**
- **O(1)**：常数空间，不随输入规模变化
- **O(n)**：线性空间，与输入规模成正比
- **O(n²)**：平方空间，二维数组
- **O(logn)**：对数空间，递归调用栈

**空间复杂度分析：**
- 考虑算法本身使用的空间
- 考虑输入数据占用的空间
- 考虑辅助空间（临时变量、递归栈等）

### 10.3 复杂度分析技巧

**1. 循环分析**
- 单层循环：O(n)
- 嵌套循环：O(n²)或O(n³)
- 循环中的操作：考虑最内层操作的复杂度

**2. 递归分析**
- 递归树方法：画出递归树，计算节点数
- 主定理：适用于分治算法
- 递推关系：建立递推关系式求解

**3. 摊还分析**
- 分析一系列操作的平均复杂度
- 适用于动态数组扩容等场景

### 10.4 时间空间权衡

**时间换空间**
- 使用更多时间减少空间使用
- 例如：不缓存计算结果，每次都重新计算

**空间换时间**
- 使用更多空间减少时间消耗
- 例如：使用哈希表加速查找

**实际应用：**
- 根据实际场景选择合适的权衡
- 考虑硬件限制（内存、CPU）
- 考虑数据规模

### 10.5 算法优化策略

**1. 减少时间复杂度**
- 使用更高效的算法
- 优化数据结构
- 减少不必要的计算

**2. 减少空间复杂度**
- 使用原地算法
- 复用空间
- 压缩存储

**3. 实际优化**
- 缓存常用结果
- 预计算
- 并行化处理

---

## 总结

本文档涵盖了数据结构和算法的主要理论知识。学习建议：

1. **理论与实践结合**：看完理论知识后立即实践
2. **循序渐进**：从基础数据结构开始，逐步学习复杂算法
3. **多做练习**：完成练习代码中的所有TODO
4. **分析复杂度**：理解每个算法的时间空间复杂度
5. **实际应用**：思考数据结构在实际项目中的应用

**推荐学习路径：**
1. 线性结构（数组、链表、栈、队列）
2. 树结构（二叉树、BST、堆）
3. 排序和查找算法
4. 图算法
5. 动态规划、贪心、回溯算法

**祝学习顺利，成为算法高手！** 💪